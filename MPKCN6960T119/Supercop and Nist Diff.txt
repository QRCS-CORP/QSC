Microsoft Windows [Version 10.0.17763.379]
(c) 2018 Microsoft Corporation. All rights reserved.

C:\Users\John>cd c:\

c:\>FC c:\mceliece\nist\benes.c c:\mceliece\scop\benes.c
Comparing files C:\MCELIECE\NIST\benes.c and C:\MCELIECE\SCOP\BENES.C
FC: no differences encountered


c:\>FC c:\mceliece\nist\bm.c c:\mceliece\scop\bm.c
Comparing files C:\MCELIECE\NIST\bm.c and C:\MCELIECE\SCOP\BM.C
***** C:\MCELIECE\NIST\bm.c
  This file is for the Berlekamp-Massey algorithm
*/
***** C:\MCELIECE\SCOP\BM.C
  This file is for the Berlekamp-Massey algorithm
  see http://crypto.stanford.edu/~mironov/cs359/massey.pdf
*/
*****

***** C:\MCELIECE\NIST\bm.c
/* the Berlekamp-Massey algorithm */
/* see http://crypto.stanford.edu/~mironov/cs359/massey.pdf */
void bm(gf *out, gf *s)
***** C:\MCELIECE\SCOP\BM.C
/* the Berlekamp-Massey algorithm */
/* input: s, sequence of field elements */
/* output: out, minimal polynomial of s */
void bm(gf *out, gf *s)
*****

***** C:\MCELIECE\NIST\bm.c

                for (i = SYS_T; i >= 1; i--) B[i] = B[i-1]; B[0] = 0;
        }
***** C:\MCELIECE\SCOP\BM.C

                for (i = SYS_T; i >= 1; i--) B[i] = B[i-1];
                B[0] = 0;
        }
*****


c:\>FC c:\mceliece\nist\controlbits.c c:\mceliece\scop\controlbits.c
Comparing files C:\MCELIECE\NIST\controlbits.c and C:\MCELIECE\SCOP\CONTROLBITS.C
***** C:\MCELIECE\NIST\controlbits.c
/*
  This file is for functions required for generating the condition bits of the Benes network w.r.t. a random permutation
  see the Lev-Pippenger-Valiant paper https://www.computer.org/csdl/trans/tc/1981/02/06312171.pdf
***** C:\MCELIECE\SCOP\CONTROLBITS.C
/*
  This file is for functions required for generating the control bits of the Benes network w.r.t. a random permutation
  see the Lev-Pippenger-Valiant paper https://www.computer.org/csdl/trans/tc/1981/02/06312171.pdf
*****

***** C:\MCELIECE\NIST\controlbits.c

static bit is_smaller_64b(uint64_t a, uint64_t b)
{
***** C:\MCELIECE\SCOP\CONTROLBITS.C

static bit is_smaller_63b(uint64_t a, uint64_t b)
{
*****

***** C:\MCELIECE\NIST\controlbits.c

  a >>= 1;
  b >>= 1;
  ret = a - b;
***** C:\MCELIECE\SCOP\CONTROLBITS.C

  ret = a - b;
*****

***** C:\MCELIECE\NIST\controlbits.c

static void cswap_64b(uint64_t *x,uint64_t *y,bit swap)
{
***** C:\MCELIECE\SCOP\CONTROLBITS.C

static void cswap_63b(uint64_t *x,uint64_t *y,bit swap)
{
*****

***** C:\MCELIECE\NIST\controlbits.c
  uint64_t d;
  uint64_t z = 0;

  z -= swap ;
  m = z;

***** C:\MCELIECE\SCOP\CONTROLBITS.C
  uint64_t d;

  m = swap;
  m = 0 - m;

*****

***** C:\MCELIECE\NIST\controlbits.c

static void minmax_64b(uint64_t *x, uint64_t *y)
{
***** C:\MCELIECE\SCOP\CONTROLBITS.C

static void minmax_63b(uint64_t *x, uint64_t *y)
{
*****

***** C:\MCELIECE\NIST\controlbits.c

  m = is_smaller_64b(*y, *x);
  cswap_64b(x, y, m);
}
***** C:\MCELIECE\SCOP\CONTROLBITS.C

  m = is_smaller_63b(*y, *x);
  cswap_63b(x, y, m);
}
*****

***** C:\MCELIECE\NIST\controlbits.c

static void merge_64b(int n,uint64_t x[n],int step)
{
***** C:\MCELIECE\SCOP\CONTROLBITS.C

static void merge_63b(int n,uint64_t x[n],int step)
{
*****

***** C:\MCELIECE\NIST\controlbits.c
  if (n == 1)
    minmax_64b(&x[0],&x[step]);
  else {
    merge_64b(n / 2,x,step * 2);
    merge_64b(n / 2,x + step,step * 2);
    for (i = 1;i < 2*n-1;i += 2)
      minmax_64b(&x[i * step],&x[(i + 1) * step]);
  }
***** C:\MCELIECE\SCOP\CONTROLBITS.C
  if (n == 1)
    minmax_63b(&x[0],&x[step]);
  else {
    merge_63b(n / 2,x,step * 2);
    merge_63b(n / 2,x + step,step * 2);
    for (i = 1;i < 2*n-1;i += 2)
      minmax_63b(&x[i * step],&x[(i + 1) * step]);
  }
*****

***** C:\MCELIECE\NIST\controlbits.c

static void sort_64b(int n, uint64_t x[n])
{
***** C:\MCELIECE\SCOP\CONTROLBITS.C

void sort_63b(int n, uint64_t x[n])
{
*****

***** C:\MCELIECE\NIST\controlbits.c
  if (n <= 1) return;
  sort_64b(n/2,x);
  sort_64b(n/2,x + n/2);
  merge_64b(n/2,x,1);
}
***** C:\MCELIECE\SCOP\CONTROLBITS.C
  if (n <= 1) return;
  sort_63b(n/2,x);
  sort_63b(n/2,x + n/2);
  merge_63b(n/2,x,1);
}
*****

***** C:\MCELIECE\NIST\controlbits.c

/* output: out, a random permutation */
static void perm_gen(uint32_t *out)
{
        int i, j, rep;

***** C:\MCELIECE\SCOP\CONTROLBITS.C

/* input: pi, a permutation*/
/* output: out, control bits w.r.t. pi */
void controlbits(unsigned char * out, uint32_t * pi)
{
        unsigned int i;
        unsigned char c[ (2*GFBITS - 1) * (1 << GFBITS) / 16 ];

        for (i = 0; i < sizeof(c); i++)
                c[i] = 0;

        controlbitsfrompermutation(GFBITS, (1 << GFBITS), 1, 0, c, pi);

        for (i = 0; i < sizeof(c); i++)
                out[i] = c[i];
}

*****

***** C:\MCELIECE\NIST\controlbits.c
        uint64_t list[ 1 << GFBITS ];

        while(1)
        {
                randombytes((unsigned char *) list, sizeof(list));

                for (i = 0; i < (1 << GFBITS); i++)
                {
                        list[i] <<= GFBITS;
                        list[i] |= i;
                }

                rep = 0;
                for (i = 1; i < (1 << GFBITS); i++)
                        for (j = 0; j < i; j++)
                                if ((list[j] >> GFBITS) == (list[i] >> GFBITS))
                                        rep = 1;

                if (rep == 0) break;
        }

        sort_64b(1 << GFBITS, list);

        for (i = 0; i < (1 << GFBITS); i++)
                out[i] = list[i] & GFMASK;
}

/* output: out, condition bits w.r.t. a random permutation */
void controlbits(unsigned char * out)
{
        int i;
        uint32_t pi[ (1 << GFBITS) ];
        unsigned char c[ (2*GFBITS - 1) * (1 << GFBITS) / 16 ];

        perm_gen(pi);

        for (i = 0; i < sizeof(c); i++)
                c[i] = 0;

        controlbitsfrompermutation(GFBITS, (1 << GFBITS), 1, 0, c, pi);

        for (i = 0; i < sizeof(c); i++)
                out[i] = c[i];
}

***** C:\MCELIECE\SCOP\CONTROLBITS.C
*****


c:\>FC c:\mceliece\nist\decrypt.c c:\mceliece\scop\decrypt.c
Comparing files C:\MCELIECE\NIST\decrypt.c and C:\MCELIECE\SCOP\DECRYPT.C
***** C:\MCELIECE\NIST\decrypt.c
        for (i = 0; i < SYND_BYTES; i++)       r[i] = c[i];
        for (i = SYND_BYTES; i < SYS_N/8; i++) r[i] = 0;
***** C:\MCELIECE\SCOP\DECRYPT.C
        for (i = 0; i < SYND_BYTES; i++)       r[i] = c[i];
        r[i-1] &= (1 << ((GFBITS * SYS_T) % 8)) - 1;
        for (i = SYND_BYTES; i < SYS_N/8; i++) r[i] = 0;
*****


c:\>FC c:\mceliece\nist\encrypt.c c:\mceliece\scop\encrypt.c
Comparing files C:\MCELIECE\NIST\encrypt.c and C:\MCELIECE\SCOP\ENCRYPT.C
***** C:\MCELIECE\NIST\encrypt.c

                eq = 0;
***** C:\MCELIECE\SCOP\ENCRYPT.C

                // check for repetition

                eq = 0;
*****


c:\>FC c:\mceliece\nist\operations.c c:\mceliece\scop\operations.c
Comparing files C:\MCELIECE\NIST\operations.c and C:\MCELIECE\SCOP\OPERATIONS.C
***** C:\MCELIECE\NIST\operations.c

#include "crypto_hash.h"

#include "params.h"
***** C:\MCELIECE\SCOP\OPERATIONS.C

#include "randombytes.h"
#include "crypto_hash.h"
#include "encrypt.h"
#include "decrypt.h"
#include "params.h"
*****

***** C:\MCELIECE\NIST\operations.c
#include "pk_gen.h"
#include "encrypt.h"
#include "decrypt.h"

#include <stdio.h>
#include <stdint.h>
***** C:\MCELIECE\SCOP\OPERATIONS.C
#include "pk_gen.h"

#include <stdint.h>
*****

***** C:\MCELIECE\NIST\operations.c
#include <string.h>
#include <stdlib.h>

***** C:\MCELIECE\SCOP\OPERATIONS.C
#include <string.h>

*****

***** C:\MCELIECE\NIST\operations.c

        memcpy(one_ec + 1,e,SYS_N/8);
        memcpy(one_ec + 1 + SYS_N/8,c,SYND_BYTES + 32);

        crypto_hash_32b(key, one_ec, sizeof one_ec);

***** C:\MCELIECE\SCOP\OPERATIONS.C

        memcpy(one_ec + 1, e, SYS_N/8);
        memcpy(one_ec + 1 + SYS_N/8, c, SYND_BYTES + 32);

        crypto_hash_32b(key, one_ec, sizeof(one_ec));

*****

***** C:\MCELIECE\NIST\operations.c
        unsigned char preimage[ 1 + SYS_N/8 + (SYND_BYTES + 32) ];

***** C:\MCELIECE\SCOP\OPERATIONS.C
        unsigned char preimage[ 1 + SYS_N/8 + (SYND_BYTES + 32) ];
        unsigned char *x = preimage;

*****

***** C:\MCELIECE\NIST\operations.c

        for (i = 0; i < 32; i++)
                ret_confirm |= conf[i] ^ c[SYND_BYTES + i];

***** C:\MCELIECE\SCOP\OPERATIONS.C

        for (i = 0; i < 32; i++) ret_confirm |= conf[i] ^ c[SYND_BYTES + i];

*****

***** C:\MCELIECE\NIST\operations.c

        {
                unsigned char *x = preimage;
                *x++ = (~m & 0) |  (m & 1);
                for (i = 0; i < SYS_N/8; i++)
                        *x++ = (~m & sk[i]) | (m & e[i]);
                for (i = 0; i < SYND_BYTES + 32; i++)
                        *x++ = c[i];
        }

***** C:\MCELIECE\SCOP\OPERATIONS.C

                                              *x++ = (~m &     0) | (m &    1);
        for (i = 0; i < SYS_N/8;         i++) *x++ = (~m & sk[i]) | (m & e[i]);
        for (i = 0; i < SYND_BYTES + 32; i++) *x++ = c[i];

*****

***** C:\MCELIECE\NIST\operations.c
        {
                sk_gen(sk);

***** C:\MCELIECE\SCOP\OPERATIONS.C
        {
                sk_part_gen(sk);

*****

***** C:\MCELIECE\NIST\operations.c

        return 0;
***** C:\MCELIECE\SCOP\OPERATIONS.C

        randombytes(sk, SYS_N/8);

        return 0;
*****


c:\>FC c:\mceliece\nist\params.c c:\mceliece\scop\params.c
FC: cannot open C:\MCELIECE\NIST\PARAMS.C - No such file or folder


c:\>FC c:\mceliece\nist\params.h c:\mceliece\scop\params.h
Comparing files C:\MCELIECE\NIST\params.h and C:\MCELIECE\SCOP\PARAMS.H
FC: no differences encountered


c:\>FC c:\mceliece\nist\pk_gen.c c:\mceliece\scop\pk_gen.c
Comparing files C:\MCELIECE\NIST\pk_gen.c and C:\MCELIECE\SCOP\PK_GEN.C
FC: no differences encountered


c:\>FC c:\mceliece\nist\root.c c:\mceliece\scop\root.c
Comparing files C:\MCELIECE\NIST\root.c and C:\MCELIECE\SCOP\ROOT.C
FC: no differences encountered


c:\>FC c:\mceliece\nist\sk_gen.c c:\mceliece\scop\sk_gen.c
Comparing files C:\MCELIECE\NIST\sk_gen.c and C:\MCELIECE\SCOP\SK_GEN.C
***** C:\MCELIECE\NIST\sk_gen.c

/* output: sk, the secret key */
int sk_gen(unsigned char *sk)
{
***** C:\MCELIECE\SCOP\SK_GEN.C

/* input: permutation represented by 32-bit integers */
/* output: an equivalent permutation represented by integers in {0, ..., 2^m-1} */
/* return  0 if no repeated intergers in the input */
/* return -1 if there are repeated intergers in the input */
int perm_conversion(uint32_t * perm)
{
*****

***** C:\MCELIECE\NIST\sk_gen.c
        int i;

        gf g[ SYS_T ]; // irreducible polynomial
        gf a[ SYS_T ]; // random element in GF(2^mt)

        while (1)
        {
                randombytes((unsigned char *) a, sizeof(a));

                for (i = 0; i < SYS_T; i++) a[i] &= GFMASK;

                if ( irr_gen(g, a) == 0 ) break;
        }
***** C:\MCELIECE\SCOP\SK_GEN.C
        int i;
        uint64_t L[ 1 << GFBITS ];

        for (i = 0; i < (1 << GFBITS); i++)
        {
                L[i] = perm[i];
                L[i] <<= 31;
                L[i] |= i;
        }
*****

***** C:\MCELIECE\NIST\sk_gen.c

        for (i = 0; i < SYS_T; i++)
                store2( sk + SYS_N/8 + i*2, g[i] );

        randombytes(sk, SYS_N/8);

        controlbits(sk + SYS_N/8 + IRR_BYTES);

***** C:\MCELIECE\SCOP\SK_GEN.C

        sort_63b(1 << GFBITS, L);

        for (i = 1; i < (1 << GFBITS); i++)
                if ((L[i-1] >> 31) == (L[i] >> 31))
                        return -1;

        for (i = 0; i < (1 << GFBITS); i++)
                perm[i] = L[i] & GFMASK;

*****

***** C:\MCELIECE\NIST\sk_gen.c
***** C:\MCELIECE\SCOP\SK_GEN.C
/* output: sk, the secret key */
int sk_part_gen(unsigned char *sk)
{
        int i;

        gf g[ SYS_T ]; // irreducible polynomial
        gf a[ SYS_T ]; // random element in GF(2^mt)

        uint32_t perm[ 1 << GFBITS ]; // random permutation

        while (1)
        {
                randombytes((unsigned char *) a, sizeof(a));

                for (i = 0; i < SYS_T; i++) a[i] &= GFMASK;

                if ( irr_gen(g, a) == 0 ) break;
        }

        while (1)
        {
                randombytes((unsigned char *) perm, sizeof(perm));

                if (perm_conversion(perm) == 0) break;
        }

        for (i = 0; i < SYS_T; i++)
                store2( sk + SYS_N/8 + i*2, g[i] );

        controlbits(sk + SYS_N/8 + IRR_BYTES, perm);

        return 0;
}

*****


c:\>FC c:\mceliece\nist\synd.c c:\mceliece\scop\synd.c
Comparing files C:\MCELIECE\NIST\synd.c and C:\MCELIECE\SCOP\SYND.C
FC: no differences encountered


c:\>FC c:\mceliece\nist\transpose.c c:\mceliece\scop\transpose.c
Comparing files C:\MCELIECE\NIST\transpose.c and C:\MCELIECE\SCOP\TRANSPOSE.C
FC: no differences encountered


c:\>FC c:\mceliece\nist\util.c c:\mceliece\scop\util.c
Comparing files C:\MCELIECE\NIST\util.c and C:\MCELIECE\SCOP\UTIL.C
FC: no differences encountered


c:\>