<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_rcs_8h" xml:lang="en-US">
<title>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/rcs.h File Reference</title>
<indexterm><primary>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/rcs.h</primary></indexterm>
<para>

<para>RCS function definitions <?linebreak?>Rijndael-256 authenticated Cipher Stream. </para>
 
</para>
<programlisting linenumbering="unnumbered">#include &quot;common.h&quot;<?linebreak?>#include &quot;sha3.h&quot;<?linebreak?>#include &quot;pmac.h&quot;<?linebreak?></programlisting><simplesect>
    <title>Data Structures    </title>
        <itemizedlist>
            <listitem><para>struct <link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link></para>

<para>The key parameters structure containing key, nonce, and info arrays and lengths. Use this structure to load an input cipher-key and optional info tweak, using the qsc_rcs_initialize function. Keys must be random and secret, and align to the corresponding key size of the cipher implemented. The info parameter is optional, and can be a salt or cryptographic key. The nonce is always QSC_RCS_BLOCK_SIZE in length. </para>
</listitem>
            <listitem><para>struct <link linkend="_structqsc__rcs__state">qsc_rcs_state</link></para>

<para>The internal state structure containing the round-key array. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Macros    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_rcs_8h_1a3700c48a7e3b2f018100a58307b72ef6"/>#define <emphasis role="strong">QSC_RCS_AUTHENTICATED</emphasis></para>

<para>Enables the AEAD cipher authentication mode. Use this flag to enable authenticated encryption for all modes. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a2aa73ffe0195a73919e3de444ff1ed41"/>#define <emphasis role="strong">QSC_RCS_AUTH_PMAC</emphasis></para>

<para>Enables the reduced rounds PMAC implementation. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a8ca13533dd16794ce4a5bad88b38e899"/>#define <emphasis role="strong">QSC_RCS_BLOCK_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The internal block size in bytes, required by the encryption and decryption functions. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1ad7e3b3a499154371f1324c4d44c7e55d"/>#define <emphasis role="strong">QSC_RCS256_KEY_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The size in bytes of the RCS-256 input cipher-key. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a67477815acb80bfb0184c0808f48819f"/>#define <emphasis role="strong">QSC_RCS256_MAC_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The RCS-256 MAC code array length in bytes. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a422b6cffe311de8245916991a78cc433"/>#define <emphasis role="strong">QSC_RCS512_KEY_SIZE</emphasis>&#160;&#160;&#160;64</para>

<para>The size in bytes of the RCS-512 input cipher-key. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a15fbf765981cad4c0a0a4f8160406c73"/>#define <emphasis role="strong">QSC_RCS512_MAC_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The RCS-512 MAC code array length in bytes. </para>
</listitem>
            <listitem><para><anchor xml:id="_rcs_8h_1a790b62fe878b8e489d86da685a0f268e"/>#define <emphasis role="strong">QSC_RCS_NONCE_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The nonce size in bytes. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Enumerations    </title>
        <itemizedlist>
            <listitem><para>enum <link linkend="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5">rcs_cipher_type</link> { <link linkend="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5a8066b8ef46ff1b2aa2c240b0971b1cd2">RCS256</link> = 1
, <link linkend="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5a1fc6600960c152f07a407ea92b300070">RCS512</link> = 2
 }</para>

<para>The pre-defined cipher mode implementations. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>QSC_EXPORT_API void <link linkend="_rcs_8h_1ad3de70d3600ee6a2a3087b9c33393d9d">qsc_rcs_dispose</link> (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> *ctx)</para>

<para>Dispose of the RCS cipher state. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_rcs_8h_1a075b831a79637abb8ef4382f5aa11c17">qsc_rcs_initialize</link> (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> *ctx, const <link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link> *keyparams, bool encryption)</para>

<para>Initialize the state with the input cipher-key and optional info tweak. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_rcs_8h_1ab68fe248c655b06d6c13f1eb281abf38">qsc_rcs_set_associated</link> (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> *ctx, const uint8_t *data, size_t length)</para>

<para>Set the associated data string used in authenticating the message. The associated data may be packet header information, domain specific data, or a secret shared by a group. The associated data must be set after initialization, and before each transformation call. The data is erased after each call to the transform. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API bool <link linkend="_rcs_8h_1a87a3085452232b535c745f711b4ebd2d">qsc_rcs_transform</link> (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> *ctx, uint8_t *output, const uint8_t *input, size_t length)</para>

<para>Transform an array of bytes. In encryption mode, the input plain-text is encrypted and then an authentication MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API bool <link linkend="_rcs_8h_1ac11273f4f473dd62b1d0866f848d1ce5">qsc_rcs_extended_transform</link> (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> *ctx, uint8_t *output, const uint8_t *input, size_t length, bool finalize)</para>

<para>A multi-call transform for a large array of bytes, such as required by file encryption. This call can be used to transform and authenticate a very large array of bytes (+1GB). On the last call in the sequence, set the finalize parameter to true to complete authentication, and write the MAC code to the end of the output array in encryption mode, or compare to the embedded MAC code and authenticate in decryption mode. In encryption mode, the input plain-text is encrypted, then authenticated, and the MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>RCS function definitions <?linebreak?>Rijndael-256 authenticated Cipher Stream. </para>

<para><formalpara><title>Author</title>

<para>John G. Underhill </para>
</formalpara>
<formalpara><title>Version</title>

<para>1.0.0.0f </para>
</formalpara>
<formalpara><title>Date</title>

<para>October 20, 2019 updated October 11, 2024 contact: <link xlink:href="mailto:john.underhill@protonmail.com">john.underhill@protonmail.com</link></para>
</formalpara>
RCS-256 encryption example <?linebreak?><literallayout><computeroutput><emphasis role="preprocessor">#define&#32;CSTLEN&#32;20</emphasis>
<emphasis role="preprocessor">#define&#32;MSGLEN&#32;200</emphasis>
uint8_t&#32;cust[CSTLEN]&#32;=&#32;{...};
uint8_t&#32;key[<link linkend="_rcs_8h_1ad7e3b3a499154371f1324c4d44c7e55d">QSC_RCS256_KEY_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;msg[MSGLEN]&#32;=&#32;{...};
uint8_t&#32;nonce[<link linkend="_rcs_8h_1a8ca13533dd16794ce4a5bad88b38e899">QSC_RCS_BLOCK_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;cpt[MSGLEN&#32;+&#32;<link linkend="_rcs_8h_1a67477815acb80bfb0184c0808f48819f">QSC_RCS256_MAC_SIZE</link>]&#32;=&#32;{&#32;0&#32;};
<link linkend="_structqsc__rcs__state">qsc_rcs_state</link>&#32;state;
<link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link>&#32;kp&#32;=&#32;{&#32;key,&#32;<link linkend="_rcs_8h_1ad7e3b3a499154371f1324c4d44c7e55d">QSC_RCS256_KEY_SIZE</link>,&#32;nonce,&#32;cust,&#32;CSTLEN&#32;};

qsc_rcs_initialize(&amp;state,&#32;&amp;kp,&#32;<emphasis role="keyword">true</emphasis>);
qsc_rcs_transform(&amp;state,&#32;cpt,&#32;msg,&#32;MSGLEN)
</computeroutput></literallayout></para>

<para>RCS-256 decryption example <?linebreak?><literallayout><computeroutput>uint8_t&#32;cpt[CPTLEN]&#32;=&#32;{&#32;qsc_rcs_transform(k,p)&#32;}
uint8_t&#32;key[<link linkend="_rcs_8h_1ad7e3b3a499154371f1324c4d44c7e55d">QSC_RCS256_KEY_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;nonce[<link linkend="_rcs_8h_1a8ca13533dd16794ce4a5bad88b38e899">QSC_RCS_BLOCK_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;cust[CSTLEN]&#32;=&#32;{...};
<emphasis role="keyword">const</emphasis>&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;MSGLEN&#32;=&#32;CPTLEN&#32;-&#32;<link linkend="_rcs_8h_1a67477815acb80bfb0184c0808f48819f">QSC_RCS256_MAC_SIZE</link>;
uint8_t&#32;msg[MSGLEN]&#32;=&#32;{&#32;0&#32;};
<link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link>&#32;kp&#32;=&#32;{&#32;key,&#32;<link linkend="_rcs_8h_1ad7e3b3a499154371f1324c4d44c7e55d">QSC_RCS256_KEY_SIZE</link>,&#32;nonce,&#32;cust,&#32;CSTLEN&#32;};

qsc_rcs_initialize(&amp;state,&#32;&amp;kp,&#32;<emphasis role="keyword">false</emphasis>);

<emphasis role="keywordflow">if</emphasis>&#32;(rcs256_transform(&amp;state,&#32;msg,&#32;cpt,&#32;MSGLEN)&#32;==&#32;<emphasis role="keyword">false</emphasis>)
{
&#32;&#32;&#32;&#32;authentication&#32;has&#32;failed,&#32;<emphasis role="keywordflow">do</emphasis>&#32;something..
}
</computeroutput></literallayout></para>

<para><formalpara><title>Remarks</title>

<para></para>
</formalpara>
<para>

<para>The RCS (Rijndael-256 authenticated Cipher Stream) encryption functions, are a hybrid of the Rijndael-256 rounds function, and a cryptographically strong pseudo-random generator function (cSHAKE) used to expand the round-key array (the key-schedule). <?linebreak?>The cryptographic XOF, generates the round key array used by the Rijndael rounds function, enabling the safe addition of increased mixing rounds, and replacing the differentially-weak native Rijndael key-schedule expansion function. <?linebreak?>The cipher increases the number of mixing rounds from 14 used by AES-256, to 22 used by RCS-256, twice the best known classical computer attack. <?linebreak?>The cipher also has a 512-bit key configuration, which uses 30 rounds of mixing. <?linebreak?>There are attacks now being proposed, that strongly indicate that larger key sizes will be necessary against future quantum-based attacks on symmetric ciphers.</para>
</para>
<para>

<para>The pseudo-random bytes generator used by this cipher is the Keccak cSHAKE extended output function (XOF). The cSHAKE XOF is implemented in 256 and 512-bit forms of those functions, correlating to the input cipher-key size. The cipher has two base variants; RCS256 and RCS512, the 256 variant using a 256-bit input key, and RCS512 using a 512-bit key. This change in key schedule expansion functions to the stronger Keccak based XOF function, can now can safely produce a larger round-key array, unlocking an increased number of mixing rounds, and preventing many serious forms of attack on the Rijndael-based ciphers.</para>
</para>
<para>

<para>This is a &apos;tweakable cipher&apos;, the initialization parameters; <link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link>, include an info parameter that can be used as a secondary user input. Internally, the info parameter is used to customize the cSHAKE output, using the cSHAKE &apos;custom&apos; parameter to pre-initialize the SHAKE state. The info parameter can be tweaked, with a user defined string &apos;info&apos; in an <link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link> structure passed to the rcs_intitialize(state,keyparams,encrypt,mode). This tweak can be used as a &apos;domain key&apos;, or to differentiate cipher-text output from other implementations, or as a secondary secret-key input.</para>
</para>
<para>

<para>RCS is an authenticated encryption with associated data (AEAD) stream cipher. It uses the hash-based key schedule extended form of Rijndael-256, wrapped in a segmented integer counter mode (CTR) for encryption. The cSHAKE key-schedule function also generates a key for the keyed hash-based MAC function; KMAC, used to generate the authentication code, which is appended to the cipher-text output of an encryption call.</para>
</para>
<para>

<para>For authentication RCS can use either the standard form of KMAC, which uses 24 rounds, or the default authentication setting; a reduced-rounds version of KMAC that uses half the number of permutation rounds KMAC-R12. To enable the standard from of KMAC, pass the QSC_RCS_AUTH_KMACR24 as a compiler definition, or unrem the definition in this header file. To run RCS without authentication, rem the QSC_RCS_AUTHENTICATED in this header file. RCS can use either a standard implementation of the Rijndael transformation functions, or one that implements CPU embedded AES-NI instructions. To enable AES-NI instructions, unrem the QSC_SYSTEM_AESNI_ENABLED definition in the <link linkend="_common_8h">common.h</link> file.</para>
</para>
<para>

<para>This implementation has both a C reference code, and an implementation that uses the AES-NI instructions that are used in the AES and RCS cipher variants. <?linebreak?>The AES-NI implementation can be enabled by adding the QSC_SYSTEM_AESNI_ENABLED constant to your preprocessor definitions. <?linebreak?>The RCS-256, RCS-512, known answer vectors are taken from the CEX++ cryptographic library <link xlink:href="https://github.com/Steppenwolfe65/CEX">The CEX++ Cryptographic Library</link>. <?linebreak?>See the documentation and the rcs_test.h tests for usage examples. To enable the AES-NI implementation, un-comment the definition in this file or add QSC_SYSTEM_AESNI_ENABLED or add it to the compiler preprocessor definitions. <?linebreak?></para>
</para>
</para>
</section>
<section>
<title>Enumeration Type Documentation</title>
<anchor xml:id="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5"/><section>
    <title>rcs_cipher_type</title>
<indexterm><primary>rcs_cipher_type</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>rcs_cipher_type</secondary></indexterm>
<para><computeroutput>enum <link linkend="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5">rcs_cipher_type</link></computeroutput></para><para>

<para>The pre-defined cipher mode implementations. </para>
</para>
<informaltable frame="all">
<title>Enumerator</title>
    <tgroup cols="2" align="left" colsep="1" rowsep="1">
      <colspec colname='c1'/>
      <colspec colname='c2'/>
<tbody>
<row><entry><indexterm><primary>RCS256</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>RCS256</secondary></indexterm>
<anchor xml:id="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5a8066b8ef46ff1b2aa2c240b0971b1cd2"/>RCS256</entry><entry>
<para>The RCS-256 cipher </para>
</entry></row><row><entry><indexterm><primary>RCS512</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>RCS512</secondary></indexterm>
<anchor xml:id="_rcs_8h_1a1b672c28ae12a1d8fa576538fa4909c5a1fc6600960c152f07a407ea92b300070"/>RCS512</entry><entry>
<para>The RCS-512 cipher </para>
</entry></row>    </tbody>
    </tgroup>
</informaltable>
</section>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_rcs_8h_1ad3de70d3600ee6a2a3087b9c33393d9d"/><section>
    <title>qsc_rcs_dispose()</title>
<indexterm><primary>qsc_rcs_dispose</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>qsc_rcs_dispose</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_rcs_dispose (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> * ctx)</computeroutput></para><para>

<para>Dispose of the RCS cipher state. </para>
</para>

<para><warning><title>Warning</title>

<para>The dispose function must be called when disposing of the cipher. This function destroys the internal state of the cipher.</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_rcs_8h_1ac11273f4f473dd62b1d0866f848d1ce5"/><section>
    <title>qsc_rcs_extended_transform()</title>
<indexterm><primary>qsc_rcs_extended_transform</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>qsc_rcs_extended_transform</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API bool qsc_rcs_extended_transform (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> * ctx, uint8_t * output, const uint8_t * input, size_t length, bool finalize)</computeroutput></para><para>

<para>A multi-call transform for a large array of bytes, such as required by file encryption. This call can be used to transform and authenticate a very large array of bytes (+1GB). On the last call in the sequence, set the finalize parameter to true to complete authentication, and write the MAC code to the end of the output array in encryption mode, or compare to the embedded MAC code and authenticate in decryption mode. In encryption mode, the input plain-text is encrypted, then authenticated, and the MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>output</entry><entry>
<para>A pointer to the output array </para>
</entry>
                            </row>
                            <row>
<entry>input</entry><entry>
<para>[const] A pointer to the input array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The number of bytes to transform </para>
</entry>
                            </row>
                            <row>
<entry>finalize</entry><entry>
<para>Complete authentication on a stream if set to true</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>: Returns true if the cipher has been transformed the data successfully, false on failure </para>
</formalpara>
</para>
</section>
<anchor xml:id="_rcs_8h_1a075b831a79637abb8ef4382f5aa11c17"/><section>
    <title>qsc_rcs_initialize()</title>
<indexterm><primary>qsc_rcs_initialize</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>qsc_rcs_initialize</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_rcs_initialize (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> * ctx, const <link linkend="_structqsc__rcs__keyparams">qsc_rcs_keyparams</link> * keyparams, bool encryption)</computeroutput></para><para>

<para>Initialize the state with the input cipher-key and optional info tweak. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>keyparams</entry><entry>
<para>[const][struct] The secret input cipher-key and nonce structure </para>
</entry>
                            </row>
                            <row>
<entry>encryption</entry><entry>
<para>Initialize the cipher for encryption, or false for decryption mode </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_rcs_8h_1ab68fe248c655b06d6c13f1eb281abf38"/><section>
    <title>qsc_rcs_set_associated()</title>
<indexterm><primary>qsc_rcs_set_associated</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>qsc_rcs_set_associated</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_rcs_set_associated (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> * ctx, const uint8_t * data, size_t length)</computeroutput></para><para>

<para>Set the associated data string used in authenticating the message. The associated data may be packet header information, domain specific data, or a secret shared by a group. The associated data must be set after initialization, and before each transformation call. The data is erased after each call to the transform. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>data</entry><entry>
<para>[const] The associated data array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The associated data array length </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_rcs_8h_1a87a3085452232b535c745f711b4ebd2d"/><section>
    <title>qsc_rcs_transform()</title>
<indexterm><primary>qsc_rcs_transform</primary><secondary>rcs.h</secondary></indexterm>
<indexterm><primary>rcs.h</primary><secondary>qsc_rcs_transform</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API bool qsc_rcs_transform (<link linkend="_structqsc__rcs__state">qsc_rcs_state</link> * ctx, uint8_t * output, const uint8_t * input, size_t length)</computeroutput></para><para>

<para>Transform an array of bytes. In encryption mode, the input plain-text is encrypted and then an authentication MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>output</entry><entry>
<para>A pointer to the output array </para>
</entry>
                            </row>
                            <row>
<entry>input</entry><entry>
<para>[const] A pointer to the input array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The number of bytes to transform</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>: Returns true if the cipher has been transformed the data successfully, false on failure </para>
</formalpara>
</para>
</section>
</section>
</section>
