<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_csx_8h" xml:lang="en-US">
<title>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/csx.h File Reference</title>
<indexterm><primary>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/csx.h</primary></indexterm>
<para>

<para>ChaCha-based authenticated Stream cipher eXtension. </para>
 
</para>
<programlisting linenumbering="unnumbered">#include &quot;common.h&quot;<?linebreak?>#include &quot;sha3.h&quot;<?linebreak?>#include &quot;pmac.h&quot;<?linebreak?></programlisting><simplesect>
    <title>Data Structures    </title>
        <itemizedlist>
            <listitem><para>struct <link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link></para>

<para>The key parameters structure containing key, nonce, and info arrays and lengths. Use this structure to load an input cipher-key and optional info tweak, using the qsc_csx_initialize function. Keys must be random and secret, and align to the corresponding key size of the cipher implemented. The info parameter is optional, and can be a salt or cryptographic key. The nonce is always QSC_CSX_BLOCK_SIZE in length. </para>
</listitem>
            <listitem><para>struct <link linkend="_structqsc__csx__state">qsc_csx_state</link></para>

<para>The internal state structure containing the round-key array. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Macros    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_csx_8h_1a41abb38a317351ca70b7c29ae8edc25c"/>#define <emphasis role="strong">QSC_CSX_AUTHENTICATED</emphasis></para>

<para>Enables KMAC authentication mode. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a850e1349b50f15a7a96aff6751a06aab"/>#define <emphasis role="strong">QSC_CSX_AUTH_PMAC</emphasis></para>

<para>Enables the reduced rounds PMAC implementation. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a801f494563418072c7cac15f53deea0d"/>#define <emphasis role="strong">QSC_CSX_BLOCK_SIZE</emphasis>&#160;&#160;&#160;128</para>

<para>The internal block size in bytes, required by the encryption and decryption functions. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a8966fccfdb20447b1c03ba7672e8f9e6"/>#define <emphasis role="strong">QSC_CSX_INFO_SIZE</emphasis>&#160;&#160;&#160;48</para>

<para>The maximum byte length of the info string. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a422344e80cc04e590c8a278a5a6263e5"/>#define <emphasis role="strong">QSC_CSX_KEY_SIZE</emphasis>&#160;&#160;&#160;64</para>

<para>The size in bytes of the CSX-512 input cipher-key. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a1a17ebd1d3e6440e22b01c03e23d7fc3"/>#define <emphasis role="strong">QSC_CSX_MAC_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The CSX MAC code array length in bytes. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1aaad87d0d2b87a9c27c9a6de576636de7"/>#define <emphasis role="strong">QSC_CSX_NONCE_SIZE</emphasis>&#160;&#160;&#160;16</para>

<para>The byte size of the nonce array. </para>
</listitem>
            <listitem><para><anchor xml:id="_csx_8h_1a85063a4106ffb3e7972b618da25aee65"/>#define <emphasis role="strong">QSC_CSX_STATE_SIZE</emphasis>&#160;&#160;&#160;16</para>

<para>The uint64 size of the internal state array. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>QSC_EXPORT_API void <link linkend="_csx_8h_1a8b31ea0f6668281d4655cf44e101f25c">qsc_csx_dispose</link> (<link linkend="_structqsc__csx__state">qsc_csx_state</link> *ctx)</para>

<para>Dispose of the CSX cipher state. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_csx_8h_1a9f4402e25572adb9ac6860c4b17e75ad">qsc_csx_initialize</link> (<link linkend="_structqsc__csx__state">qsc_csx_state</link> *ctx, const <link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link> *keyparams, bool encryption)</para>

<para>Initialize the state with the input cipher-key and optional info tweak. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_csx_8h_1a5eb9d323b45bef12eabe68852a136be6">qsc_csx_set_associated</link> (<link linkend="_structqsc__csx__state">qsc_csx_state</link> *ctx, const uint8_t *data, size_t length)</para>

<para>Set the associated data string used in authenticating the message. The associated data may be packet header information, domain specific data, or a secret shared by a group. The associated data must be set after initialization, and before each transformation call. The data is erased after each call to the transform. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API bool <link linkend="_csx_8h_1a071d11fa66ebccee8e8fc7ae9bc58696">qsc_csx_transform</link> (<link linkend="_structqsc__csx__state">qsc_csx_state</link> *ctx, uint8_t *output, const uint8_t *input, size_t length)</para>

<para>Transform an array of bytes. In encryption mode, the input plain-text is encrypted and then an authentication MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API bool <link linkend="_csx_8h_1ab70bbd32fd86948d6206b1c48b75deea">qsc_csx_extended_transform</link> (<link linkend="_structqsc__csx__state">qsc_csx_state</link> *ctx, uint8_t *output, const uint8_t *input, size_t length, bool finalize)</para>

<para>A multi-call transform for a large array of bytes, such as required by file encryption. This call can be used to transform and authenticate a very large array of bytes (+1GB). On the last call in the sequence, set the finalize parameter to true to complete authentication, and write the MAC code to the end of the output array in encryption mode, or compare to the embedded MAC code and authenticate in decryption mode. In encryption mode, the input plain-text is encrypted, then authenticated, and the MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>ChaCha-based authenticated Stream cipher eXtension. </para>

<para><formalpara><title>Author</title>

<para>John G. Underhill </para>
</formalpara>
<formalpara><title>Version</title>

<para>1.0.0.0b </para>
</formalpara>
<formalpara><title>Date</title>

<para>May 2, 2020 updated October 13, 2021 contact: <link xlink:href="mailto:john.underhill@protonmail.com">john.underhill@protonmail.com</link></para>
</formalpara>
CSX-512 encryption example <?linebreak?><literallayout><computeroutput><emphasis role="comment">//&#32;external&#32;message,&#32;key,&#32;nonce,&#32;and&#32;custom-info&#32;arrays</emphasis>
<emphasis role="preprocessor">#define&#32;CSTLEN&#32;20</emphasis>
<emphasis role="preprocessor">#define&#32;MSGLEN&#32;200</emphasis>
uint8_t&#32;cust[CSTLEN]&#32;=&#32;{...};
uint8_t&#32;key[<link linkend="_csx_8h_1a422344e80cc04e590c8a278a5a6263e5">QSC_CSX_KEY_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;msg[MSGLEN]&#32;=&#32;{...};
uint8_t&#32;nonce[<link linkend="_csx_8h_1aaad87d0d2b87a9c27c9a6de576636de7">QSC_CSX_NONCE_SIZE</link>]&#32;=&#32;{...};
...
uint8_t&#32;cpt[MSGLEN&#32;+&#32;<link linkend="_csx_8h_1a1a17ebd1d3e6440e22b01c03e23d7fc3">QSC_CSX_MAC_SIZE</link>]&#32;=&#32;{&#32;0&#32;};
<link linkend="_structqsc__csx__state">qsc_csx_state</link>&#32;state;
<link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link>&#32;kp&#32;=&#32;{&#32;key,&#32;<link linkend="_csx_8h_1a422344e80cc04e590c8a278a5a6263e5">QSC_CSX_KEY_SIZE</link>,&#32;nonce,&#32;cust,&#32;CSTLEN&#32;};

<emphasis role="comment">//&#32;initialize&#32;the&#32;state</emphasis>
qsc_csx_initialize(&amp;state,&#32;&amp;kp,&#32;<emphasis role="keyword">true</emphasis>);
<emphasis role="comment">//&#32;encrypt&#32;the&#32;message</emphasis>
qsc_csx_transform(&amp;state,&#32;cpt,&#32;msg,&#32;MSGLEN)
</computeroutput></literallayout></para>

<para>CSX-512 decryption example <?linebreak?><literallayout><computeroutput><emphasis role="comment">//&#32;external&#32;cipher-text,&#32;key&#32;and&#32;custom-info&#32;arrays,</emphasis>
<emphasis role="comment">//&#32;and&#32;cipher-text&#32;containing&#32;the&#32;encrypted&#32;plain-text&#32;and&#32;the&#32;mac-code</emphasis>
uint8_t&#32;cpt[CPT_LEN]&#32;=&#32;{&#32;qsc_csx_transform(k,p)&#32;}
uint8_t&#32;key[<link linkend="_csx_8h_1a422344e80cc04e590c8a278a5a6263e5">QSC_CSX_KEY_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;nonce[<link linkend="_csx_8h_1aaad87d0d2b87a9c27c9a6de576636de7">QSC_CSX_NONCE_SIZE</link>]&#32;=&#32;{...};
uint8_t&#32;cust[CSTLEN]&#32;=&#32;{...};
...
<emphasis role="comment">//&#32;subtract&#32;the&#32;mac-code&#32;length&#32;from&#32;the&#32;overall&#32;cipher-text&#32;length&#32;for&#32;the&#32;message&#32;size</emphasis>
const&#32;<emphasis role="keywordtype">size_t</emphasis>&#32;MSGLEN&#32;=&#32;CPT_LEN&#32;-&#32;<link linkend="_csx_8h_1a1a17ebd1d3e6440e22b01c03e23d7fc3">QSC_CSX_MAC_SIZE</link>;
uint8_t&#32;msg[MSGLEN]&#32;=&#32;{&#32;0&#32;};
<link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link>&#32;kp&#32;=&#32;{&#32;key,&#32;<link linkend="_csx_8h_1a422344e80cc04e590c8a278a5a6263e5">QSC_CSX_KEY_SIZE</link>,&#32;nonce,&#32;cust,&#32;CSTLEN&#32;};

<emphasis role="comment">//&#32;initialize&#32;the&#32;cipher&#32;state&#32;for&#32;decryption</emphasis>
qsc_csx_initialize(&amp;state,&#32;&amp;kp,&#32;<emphasis role="keyword">false</emphasis>);

<emphasis role="comment">//&#32;authenticate&#32;and&#32;decrypt&#32;the&#32;cipher-text</emphasis>
<emphasis role="keywordflow">if</emphasis>&#32;(qsc_csx_transform(&amp;state,&#32;msg,&#32;cpt,&#32;MSGLEN)&#32;==&#32;<emphasis role="keyword">false</emphasis>)
{
&#32;&#32;<emphasis role="comment">//&#32;authentication&#32;has&#32;failed,&#32;do&#32;something..</emphasis>
}
</computeroutput></literallayout></para>

<para><formalpara><title>Remarks</title>

<para></para>
</formalpara>
<para>

<para>An [EXPERIMENTAL] vectorized, 64-bit, 40-round stream cipher [CSX512] implementation based on ChaCha. This cipher uses KMAC-512 to authenticate the cipher-text stream in an encrypt-then-mac authentication configuration. The CSX (authenticated Cipher Stream, ChaCha eXtended) cipher, is a hybrid of the ChaCha stream cipher, using 64-bit integers, a 1024-bit block and a 512-bit key. <?linebreak?> </para>
</para>
<para>

<para>The pseudo-random bytes generator used by this cipher is the Keccak cSHAKE extended output function (XOF). The cSHAKE XOF is implemented in the 512-bit form of that function, and used to expand the input cipher-key into the cipher and MAC keys. CSX-512 uses a 512-bit input key, an a 16 byte nonce, and an optional tweak; the info parameter, up to 48 bytes in length.</para>
</para>
<para>

<para>This is a &apos;tweakable cipher&apos;, the initialization parameters; <link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link>, include an info parameter that can be used as a secondary user input. Internally, the info parameter is used to customize the cSHAKE output, using the cSHAKE &apos;custom&apos; parameter to pre-initialize the SHAKE state. The info parameter can be tweaked, with a user defined string &apos;info&apos; in an <link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link> structure passed to the csx_intitialize(state,keyparams,encrypt). This tweak can be used as a &apos;domain key&apos;, or to differentiate cipher-text output from other implementations, or as a secondary secret-key input.</para>
</para>
<para>

<para>CSX is an authenticated encryption with associated data (AEAD) stream cipher. The cSHAKE key-expansion function generates a key for the keyed hash-based MAC function; KMAC, used to generate the authentication code, which is appended to the cipher-text output of an encryption call. In decryption mode, before decryption is performed, an internal mac code is calculated, and compared to the code embedded in the cipher-text. If authentication fails, the cipher-text is not decrypted, and the qsc_csx_transform(state,out,in,inlen) function returns a boolean false value. The qsc_csx_set_associated(state,in,inlen) function can be used to add additional data to the MAC generators input, like packet-header data, or a custom code or counter.</para>
</para>
<para>

<para>For authentication CSX can use either the standard form of KMAC, which uses 24 rounds, or the default authentication setting; a reduced-rounds version of KMAC that uses half the number of permutation rounds KMAC-R12. To enable the standard from of KMAC, pass the QSC_RCS_AUTH_KMACR24 as a compiler definition, or unrem the definition in this header file. To run CSX without authentication, remove the QSC_RCS_AUTHENTICATED in this header file.</para>
</para>
<para>

<para>The CSX-512, known answer vectors are taken from the CEX++ cryptographic library <link xlink:href="https://github.com/Steppenwolfe65/CEX">The CEX++ Cryptographic Library</link>. <?linebreak?>See the documentation and the csx_test.h tests for usage examples. </para>
</para>
</para>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_csx_8h_1a8b31ea0f6668281d4655cf44e101f25c"/><section>
    <title>qsc_csx_dispose()</title>
<indexterm><primary>qsc_csx_dispose</primary><secondary>csx.h</secondary></indexterm>
<indexterm><primary>csx.h</primary><secondary>qsc_csx_dispose</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_csx_dispose (<link linkend="_structqsc__csx__state">qsc_csx_state</link> * ctx)</computeroutput></para><para>

<para>Dispose of the CSX cipher state. </para>
</para>

<para><warning><title>Warning</title>

<para>The dispose function must be called when disposing of the cipher. This function destroys the internal state of the cipher.</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_csx_8h_1ab70bbd32fd86948d6206b1c48b75deea"/><section>
    <title>qsc_csx_extended_transform()</title>
<indexterm><primary>qsc_csx_extended_transform</primary><secondary>csx.h</secondary></indexterm>
<indexterm><primary>csx.h</primary><secondary>qsc_csx_extended_transform</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API bool qsc_csx_extended_transform (<link linkend="_structqsc__csx__state">qsc_csx_state</link> * ctx, uint8_t * output, const uint8_t * input, size_t length, bool finalize)</computeroutput></para><para>

<para>A multi-call transform for a large array of bytes, such as required by file encryption. This call can be used to transform and authenticate a very large array of bytes (+1GB). On the last call in the sequence, set the finalize parameter to true to complete authentication, and write the MAC code to the end of the output array in encryption mode, or compare to the embedded MAC code and authenticate in decryption mode. In encryption mode, the input plain-text is encrypted, then authenticated, and the MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>output</entry><entry>
<para>A pointer to the output array </para>
</entry>
                            </row>
                            <row>
<entry>input</entry><entry>
<para>[const] A pointer to the input array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The number of bytes to transform </para>
</entry>
                            </row>
                            <row>
<entry>finalize</entry><entry>
<para>Complete authentication on a stream if set to true</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>: Returns true if the cipher has been transformed the data successfully, false on failure </para>
</formalpara>
</para>
</section>
<anchor xml:id="_csx_8h_1a9f4402e25572adb9ac6860c4b17e75ad"/><section>
    <title>qsc_csx_initialize()</title>
<indexterm><primary>qsc_csx_initialize</primary><secondary>csx.h</secondary></indexterm>
<indexterm><primary>csx.h</primary><secondary>qsc_csx_initialize</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_csx_initialize (<link linkend="_structqsc__csx__state">qsc_csx_state</link> * ctx, const <link linkend="_structqsc__csx__keyparams">qsc_csx_keyparams</link> * keyparams, bool encryption)</computeroutput></para><para>

<para>Initialize the state with the input cipher-key and optional info tweak. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>keyparams</entry><entry>
<para>[const][struct] The secret input cipher-key and nonce structure </para>
</entry>
                            </row>
                            <row>
<entry>encryption</entry><entry>
<para>Initialize the cipher for encryption, or false for decryption mode </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_csx_8h_1a5eb9d323b45bef12eabe68852a136be6"/><section>
    <title>qsc_csx_set_associated()</title>
<indexterm><primary>qsc_csx_set_associated</primary><secondary>csx.h</secondary></indexterm>
<indexterm><primary>csx.h</primary><secondary>qsc_csx_set_associated</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_csx_set_associated (<link linkend="_structqsc__csx__state">qsc_csx_state</link> * ctx, const uint8_t * data, size_t length)</computeroutput></para><para>

<para>Set the associated data string used in authenticating the message. The associated data may be packet header information, domain specific data, or a secret shared by a group. The associated data must be set after initialization, and before each transformation call. The data is erased after each call to the transform. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>data</entry><entry>
<para>[const] The associated data array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The associated data array length </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_csx_8h_1a071d11fa66ebccee8e8fc7ae9bc58696"/><section>
    <title>qsc_csx_transform()</title>
<indexterm><primary>qsc_csx_transform</primary><secondary>csx.h</secondary></indexterm>
<indexterm><primary>csx.h</primary><secondary>qsc_csx_transform</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API bool qsc_csx_transform (<link linkend="_structqsc__csx__state">qsc_csx_state</link> * ctx, uint8_t * output, const uint8_t * input, size_t length)</computeroutput></para><para>

<para>Transform an array of bytes. In encryption mode, the input plain-text is encrypted and then an authentication MAC code is appended to the cipher-text. In decryption mode, the input cipher-text is authenticated internally and compared to the MAC code appended to the cipher-text, if the codes to not match, the cipher-text is not decrypted and the call fails. </para>
</para>

<para><warning><title>Warning</title>

<para>The cipher must be initialized before this function can be called</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The cipher state structure </para>
</entry>
                            </row>
                            <row>
<entry>output</entry><entry>
<para>A pointer to the output array </para>
</entry>
                            </row>
                            <row>
<entry>input</entry><entry>
<para>[const] A pointer to the input array </para>
</entry>
                            </row>
                            <row>
<entry>length</entry><entry>
<para>The number of bytes to transform</para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                <formalpara><title>Returns</title>

<para>: Returns true if the cipher has been transformed the data successfully, false on failure </para>
</formalpara>
</para>
</section>
</section>
</section>
