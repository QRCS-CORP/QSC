\hypertarget{poly_8h}{}\section{C\+:/\+Users/\+John/\+Documents/\+Visual Studio 2015/\+Projects/\+Cryptography/\+New\+Hope/\+New\+Hope/\+New\+Hope/poly.h File Reference}
\label{poly_8h}\index{C\+:/\+Users/\+John/\+Documents/\+Visual Studio 2015/\+Projects/\+Cryptography/\+New\+Hope/\+New\+Hope/\+New\+Hope/poly.\+h@{C\+:/\+Users/\+John/\+Documents/\+Visual Studio 2015/\+Projects/\+Cryptography/\+New\+Hope/\+New\+Hope/\+New\+Hope/poly.\+h}}


{\bfseries New\+Hope polynomial api} ~\newline
This is an internal class.  


{\ttfamily \#include \char`\"{}common.\+h\char`\"{}}\\*
{\ttfamily \#include \char`\"{}params.\+h\char`\"{}}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct \hyperlink{structpoly}{poly}
\begin{DoxyCompactList}\small\item\em Contains an N sized array of 16bit coefficients. /n Elements of R\+\_\+q = Z\+\_\+q\mbox{[}X\mbox{]} / (X$^\wedge$n + 1). /n Represents polynomial coeffs\mbox{[}0\mbox{]} + X $\ast$ coeffs\mbox{[}1\mbox{]} + X$^\wedge$2 $\ast$ xoeffs\mbox{[}2\mbox{]} + ... + X$^\wedge$\{n-\/1\} $\ast$ coeffs\mbox{[}n-\/1\mbox{]}. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
void \hyperlink{poly_8h_a60e643ca2b26cd91dc51512e86b5afd9}{poly\+\_\+add} (\hyperlink{structpoly}{poly} $\ast$r, const \hyperlink{structpoly}{poly} $\ast$a, const \hyperlink{structpoly}{poly} $\ast$b)
\begin{DoxyCompactList}\small\item\em Add two polynomials. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a592b6753d0c9faed779e9bb998c6f26b}{poly\+\_\+compress} (uint8\+\_\+t $\ast$r, const \hyperlink{structpoly}{poly} $\ast$p)
\begin{DoxyCompactList}\small\item\em Compression and subsequent serialization of a polynomial. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_afc135a1baac96757d3af6caaef09b4a3}{poly\+\_\+decompress} (\hyperlink{structpoly}{poly} $\ast$r, const uint8\+\_\+t $\ast$a)
\begin{DoxyCompactList}\small\item\em De-\/serialization and subsequent decompression of a polynomial; approximate inverse of poly\+\_\+compress. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a549b5bf1a8e080a0f714fdd8739f2717}{poly\+\_\+frombytes} (\hyperlink{structpoly}{poly} $\ast$r, const uint8\+\_\+t $\ast$a)
\begin{DoxyCompactList}\small\item\em De-\/serialization of a polynomial. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a9d3a1f11c08db50c3c373e9028ad770f}{poly\+\_\+frommsg} (\hyperlink{structpoly}{poly} $\ast$r, const uint8\+\_\+t $\ast$msg)
\begin{DoxyCompactList}\small\item\em Convert 32-\/byte message to polynomial. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_ae754ec12e39dad0084a7cbe211951de7}{poly\+\_\+invntt} (\hyperlink{structpoly}{poly} $\ast$r)
\begin{DoxyCompactList}\small\item\em Inverse N\+T\+T transform of a polynomial in place Input is assumed to have coefficients in normal order Output has coefficients in normal order. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_aa3758e8748217216d3935130363386e9}{poly\+\_\+mul\+\_\+pointwise} (\hyperlink{structpoly}{poly} $\ast$r, const \hyperlink{structpoly}{poly} $\ast$a, const \hyperlink{structpoly}{poly} $\ast$b)
\begin{DoxyCompactList}\small\item\em Multiply two polynomials pointwise (i.\+e., coefficient-\/wise) \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a14ede59cdb27dad503701b4ac487105a}{poly\+\_\+ntt} (\hyperlink{structpoly}{poly} $\ast$r)
\begin{DoxyCompactList}\small\item\em Forward N\+T\+T transform of a polynomial in place. Input is assumed to have coefficients in bitreversed order Output has coefficients in normal order. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_ada247b54673302ee30a477dcbf64bc33}{poly\+\_\+sample} (\hyperlink{structpoly}{poly} $\ast$r, const uint8\+\_\+t $\ast$seed, uint8\+\_\+t nonce)
\begin{DoxyCompactList}\small\item\em Sample a polynomial deterministically from a seed and a nonce, with output polynomial close to centered binomial distribution with parameter k=8. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_ab7079a3c50e5acaf474c9b0b23efc7ff}{poly\+\_\+tomsg} (uint8\+\_\+t $\ast$msg, const \hyperlink{structpoly}{poly} $\ast$x)
\begin{DoxyCompactList}\small\item\em Convert polynomial to 32-\/byte message. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a54925c2e3434b57ba3e201df8f917622}{poly\+\_\+sub} (\hyperlink{structpoly}{poly} $\ast$r, const \hyperlink{structpoly}{poly} $\ast$a, const \hyperlink{structpoly}{poly} $\ast$b)
\begin{DoxyCompactList}\small\item\em Subtract two polynomials. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a74ca05decacf688f67e83b5b1c8693b4}{poly\+\_\+tobytes} (uint8\+\_\+t $\ast$r, const \hyperlink{structpoly}{poly} $\ast$p)
\begin{DoxyCompactList}\small\item\em Serialization of a polynomial. \end{DoxyCompactList}\item 
void \hyperlink{poly_8h_a19a6287ab3b32d3b9c2af5f0a14e9e27}{poly\+\_\+uniform} (\hyperlink{structpoly}{poly} $\ast$a, const uint8\+\_\+t $\ast$seed)
\begin{DoxyCompactList}\small\item\em Sample a polynomial deterministically from a seed, with output polynomial looking uniformly random. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
{\bfseries New\+Hope polynomial api} ~\newline
This is an internal class. 

\begin{DoxyDate}{Date}
February 16, 2018 
\end{DoxyDate}


\subsection{Function Documentation}
\hypertarget{poly_8h_a60e643ca2b26cd91dc51512e86b5afd9}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+add@{poly\+\_\+add}}
\index{poly\+\_\+add@{poly\+\_\+add}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+add}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+add (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const {\bf poly} $\ast$}]{a, }
\item[{const {\bf poly} $\ast$}]{b}
\end{DoxyParamCaption}
)}\label{poly_8h_a60e643ca2b26cd91dc51512e86b5afd9}


Add two polynomials. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em a} & pointer to first input polynomial \\
\hline
{\em b} & pointer to second input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a592b6753d0c9faed779e9bb998c6f26b}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+compress@{poly\+\_\+compress}}
\index{poly\+\_\+compress@{poly\+\_\+compress}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+compress}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+compress (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{r, }
\item[{const {\bf poly} $\ast$}]{p}
\end{DoxyParamCaption}
)}\label{poly_8h_a592b6753d0c9faed779e9bb998c6f26b}


Compression and subsequent serialization of a polynomial. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output byte array \\
\hline
{\em p} & pointer to input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_afc135a1baac96757d3af6caaef09b4a3}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+decompress@{poly\+\_\+decompress}}
\index{poly\+\_\+decompress@{poly\+\_\+decompress}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+decompress}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+decompress (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const uint8\+\_\+t $\ast$}]{a}
\end{DoxyParamCaption}
)}\label{poly_8h_afc135a1baac96757d3af6caaef09b4a3}


De-\/serialization and subsequent decompression of a polynomial; approximate inverse of poly\+\_\+compress. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em a} & pointer to input byte array \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a549b5bf1a8e080a0f714fdd8739f2717}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+frombytes@{poly\+\_\+frombytes}}
\index{poly\+\_\+frombytes@{poly\+\_\+frombytes}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+frombytes}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+frombytes (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const uint8\+\_\+t $\ast$}]{a}
\end{DoxyParamCaption}
)}\label{poly_8h_a549b5bf1a8e080a0f714fdd8739f2717}


De-\/serialization of a polynomial. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em a} & pointer to input byte array \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a9d3a1f11c08db50c3c373e9028ad770f}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+frommsg@{poly\+\_\+frommsg}}
\index{poly\+\_\+frommsg@{poly\+\_\+frommsg}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+frommsg}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+frommsg (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const uint8\+\_\+t $\ast$}]{msg}
\end{DoxyParamCaption}
)}\label{poly_8h_a9d3a1f11c08db50c3c373e9028ad770f}


Convert 32-\/byte message to polynomial. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em msg} & pointer to input message \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_ae754ec12e39dad0084a7cbe211951de7}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+invntt@{poly\+\_\+invntt}}
\index{poly\+\_\+invntt@{poly\+\_\+invntt}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+invntt}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+invntt (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r}
\end{DoxyParamCaption}
)}\label{poly_8h_ae754ec12e39dad0084a7cbe211951de7}


Inverse N\+T\+T transform of a polynomial in place Input is assumed to have coefficients in normal order Output has coefficients in normal order. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to input/output polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_aa3758e8748217216d3935130363386e9}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+mul\+\_\+pointwise@{poly\+\_\+mul\+\_\+pointwise}}
\index{poly\+\_\+mul\+\_\+pointwise@{poly\+\_\+mul\+\_\+pointwise}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+mul\+\_\+pointwise}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+mul\+\_\+pointwise (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const {\bf poly} $\ast$}]{a, }
\item[{const {\bf poly} $\ast$}]{b}
\end{DoxyParamCaption}
)}\label{poly_8h_aa3758e8748217216d3935130363386e9}


Multiply two polynomials pointwise (i.\+e., coefficient-\/wise) 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em a} & pointer to first input polynomial \\
\hline
{\em b} & pointer to second input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a14ede59cdb27dad503701b4ac487105a}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+ntt@{poly\+\_\+ntt}}
\index{poly\+\_\+ntt@{poly\+\_\+ntt}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+ntt}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+ntt (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r}
\end{DoxyParamCaption}
)}\label{poly_8h_a14ede59cdb27dad503701b4ac487105a}


Forward N\+T\+T transform of a polynomial in place. Input is assumed to have coefficients in bitreversed order Output has coefficients in normal order. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to input/output polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_ada247b54673302ee30a477dcbf64bc33}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+sample@{poly\+\_\+sample}}
\index{poly\+\_\+sample@{poly\+\_\+sample}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+sample}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+sample (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const uint8\+\_\+t $\ast$}]{seed, }
\item[{uint8\+\_\+t}]{nonce}
\end{DoxyParamCaption}
)}\label{poly_8h_ada247b54673302ee30a477dcbf64bc33}


Sample a polynomial deterministically from a seed and a nonce, with output polynomial close to centered binomial distribution with parameter k=8. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em seed} & pointer to input seed \\
\hline
{\em nonce} & one byte input nonce \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a54925c2e3434b57ba3e201df8f917622}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+sub@{poly\+\_\+sub}}
\index{poly\+\_\+sub@{poly\+\_\+sub}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+sub}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+sub (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{r, }
\item[{const {\bf poly} $\ast$}]{a, }
\item[{const {\bf poly} $\ast$}]{b}
\end{DoxyParamCaption}
)}\label{poly_8h_a54925c2e3434b57ba3e201df8f917622}


Subtract two polynomials. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output polynomial \\
\hline
{\em a} & pointer to first input polynomial \\
\hline
{\em b} & pointer to second input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a74ca05decacf688f67e83b5b1c8693b4}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+tobytes@{poly\+\_\+tobytes}}
\index{poly\+\_\+tobytes@{poly\+\_\+tobytes}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+tobytes}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+tobytes (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{r, }
\item[{const {\bf poly} $\ast$}]{p}
\end{DoxyParamCaption}
)}\label{poly_8h_a74ca05decacf688f67e83b5b1c8693b4}


Serialization of a polynomial. 


\begin{DoxyParams}{Parameters}
{\em r} & pointer to output byte array \\
\hline
{\em p} & pointer to input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_ab7079a3c50e5acaf474c9b0b23efc7ff}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+tomsg@{poly\+\_\+tomsg}}
\index{poly\+\_\+tomsg@{poly\+\_\+tomsg}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+tomsg}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+tomsg (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t $\ast$}]{msg, }
\item[{const {\bf poly} $\ast$}]{x}
\end{DoxyParamCaption}
)}\label{poly_8h_ab7079a3c50e5acaf474c9b0b23efc7ff}


Convert polynomial to 32-\/byte message. 


\begin{DoxyParams}{Parameters}
{\em msg} & pointer to output message \\
\hline
{\em x} & pointer to input polynomial \\
\hline
\end{DoxyParams}
\hypertarget{poly_8h_a19a6287ab3b32d3b9c2af5f0a14e9e27}{}\index{poly.\+h@{poly.\+h}!poly\+\_\+uniform@{poly\+\_\+uniform}}
\index{poly\+\_\+uniform@{poly\+\_\+uniform}!poly.\+h@{poly.\+h}}
\subsubsection[{poly\+\_\+uniform}]{\setlength{\rightskip}{0pt plus 5cm}void poly\+\_\+uniform (
\begin{DoxyParamCaption}
\item[{{\bf poly} $\ast$}]{a, }
\item[{const uint8\+\_\+t $\ast$}]{seed}
\end{DoxyParamCaption}
)}\label{poly_8h_a19a6287ab3b32d3b9c2af5f0a14e9e27}


Sample a polynomial deterministically from a seed, with output polynomial looking uniformly random. 


\begin{DoxyParams}{Parameters}
{\em a} & pointer to output polynomial \\
\hline
{\em seed} & pointer to input seed \\
\hline
\end{DoxyParams}
