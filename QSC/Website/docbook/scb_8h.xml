<?xml version='1.0' encoding='UTF-8' standalone='no'?>
<section xmlns="http://docbook.org/ns/docbook" version="5.0" xmlns:xlink="http://www.w3.org/1999/xlink" xml:id="_scb_8h" xml:lang="en-US">
<title>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/scb.h File Reference</title>
<indexterm><primary>C:/Users/stepp/Documents/Visual Studio 2022/Projects/C/QSC/QSC/scb.h</primary></indexterm>
<para>

<para>An implementation of the SHAKE Cost Based key derivation function: SCB-KDF. </para>
 
</para>
<programlisting linenumbering="unnumbered">#include &quot;common.h&quot;<?linebreak?>#include &quot;sha3.h&quot;<?linebreak?></programlisting><simplesect>
    <title>Data Structures    </title>
        <itemizedlist>
            <listitem><para>struct <link linkend="_structqsc__scb__state">qsc_scb_state</link></para>

<para>The CSG state structure. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Macros    </title>
        <itemizedlist>
            <listitem><para><anchor xml:id="_scb_8h_1a14f11e08f14932c25a9d5878c26c2739"/>#define <emphasis role="strong">QSC_SCB_256_SEED_SIZE</emphasis>&#160;&#160;&#160;32</para>

<para>The SCB-256 seed size. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1af04f804f5e916ce3fe92948a7d4a0eee"/>#define <emphasis role="strong">QSC_SCB_512_SEED_SIZE</emphasis>&#160;&#160;&#160;64</para>

<para>The SCB-512 seed size. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a8c166f3f439d46eb500cd757ced24572"/>#define <emphasis role="strong">QSC_SCB_L2CACHE_DEFAULT_SIZE</emphasis>&#160;&#160;&#160;(1024 * 256)</para>

<para>The default L2 cache size (256 KiB). Smaller sizes will not be affected by a diminished cache miss rate, but larger sizes (doubling from 256 to 512, 1024, 2048...) is possible if tuning for increased cache misses on specific architectures with large L2 cache sizes. If increasing the L2 cache size the memory cost minimum also increases, so that the memory cost must be divisible by 4 times the L2 cache size. The minimum memcost with a 512 KiB cache is memcost=2 or 2 MiB, with a 1024 Kib cache size (1 MiB) the memcost minimum must be 4, or 4 MiB of memory cost buffering. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a318b0cdfc90eca709e5204301fbc9616"/>#define <emphasis role="strong">QSC_SCB_MEMORY_COST_SIZE</emphasis>&#160;&#160;&#160;(1024 * 1024)</para>

<para>The base memory cost of 1 MiB (1,048,576 bytes) </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a157dcb1b3b6d20d5adc776a5e76c4eb9"/>#define <emphasis role="strong">QSC_SCB_MEMORY_MAXIMUM</emphasis>&#160;&#160;&#160;128</para>

<para>The maximum memory cost. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a43440e56d1124af033fb80f51e550771"/>#define <emphasis role="strong">QSC_SCB_MEMORY_MINIMUM</emphasis>&#160;&#160;&#160;1</para>

<para>The minimum memory cost. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a009ddba9935e6b3305b4a3ae43856cfe"/>#define <emphasis role="strong">QSC_SCB_CPU_MINIMUM</emphasis>&#160;&#160;&#160;1</para>

<para>The minimum CPU cost multiplier. </para>
</listitem>
            <listitem><para><anchor xml:id="_scb_8h_1a1ab3242cf825f88c7b4b843dfcf74448"/>#define <emphasis role="strong">QSC_SCB_CPU_MAXIMUM</emphasis>&#160;&#160;&#160;1000</para>

<para>The maximum CPU cost multiplier. </para>
</listitem>
        </itemizedlist>
</simplesect>
<simplesect>
    <title>Functions    </title>
        <itemizedlist>
            <listitem><para>QSC_EXPORT_API void <link linkend="_scb_8h_1a12d0a4d316949c8e927055d7d8de97af">qsc_scb_dispose</link> (<link linkend="_structqsc__scb__state">qsc_scb_state</link> *ctx)</para>

<para>Dispose of the DRBG state. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_scb_8h_1a0d452fcb95ea81c7fc7e39910525321b">qsc_scb_initialize</link> (<link linkend="_structqsc__scb__state">qsc_scb_state</link> *ctx, const uint8_t *seed, size_t seedlen, const uint8_t *info, size_t infolen, size_t cpucost, size_t memcost)</para>

<para>Initialize the pseudo-random provider state with a seed and optional personalization string. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_scb_8h_1a2c5f0aa797f606428c24c90121167ec9">qsc_scb_generate</link> (<link linkend="_structqsc__scb__state">qsc_scb_state</link> *ctx, uint8_t *output, size_t otplen)</para>

<para>Generate pseudo-random bytes using the random provider. </para>
</listitem>
            <listitem><para>QSC_EXPORT_API void <link linkend="_scb_8h_1a974f89f0ba4e953d66e92fcbeae568c4">qsc_scb_update</link> (<link linkend="_structqsc__scb__state">qsc_scb_state</link> *ctx, const uint8_t *seed, size_t seedlen)</para>

<para>Update the random provider with new keying material. </para>
</listitem>
        </itemizedlist>
</simplesect>
<section>
<title>Detailed Description</title>

<para>An implementation of the SHAKE Cost Based key derivation function: SCB-KDF. </para>

<para>Usage Example <?linebreak?> Initialize the DRBG and generate output <?linebreak?><literallayout><computeroutput><emphasis role="comment">//&#32;external&#32;key&#32;and&#32;optional&#32;custom&#32;arrays</emphasis>
uint8_t&#32;seed[32]&#32;=&#32;{&#32;...&#32;};
uint8_t&#32;info[32]&#32;=&#32;{&#32;...&#32;};

<emphasis role="comment">//&#32;output&#32;bytes</emphasis>
uint8_t&#32;rnd[200]&#32;=&#32;{&#32;0&#32;};

<emphasis role="comment">//&#32;initialize&#32;with&#32;seed,&#32;and&#32;optional&#32;info&#32;array,&#32;with&#32;a&#32;cpu&#32;cost&#32;of&#32;2,&#32;and&#32;a&#32;memory&#32;cost&#32;of&#32;1.</emphasis>
qsc_scb_initialize(seed,&#32;<emphasis role="keyword">sizeof</emphasis>(seed),&#32;info,&#32;<emphasis role="keyword">sizeof</emphasis>(info),&#32;2,&#32;1);

<emphasis role="comment">//&#32;generate&#32;the&#32;pseudo-random</emphasis>
qsc_scb_generate(rnd,&#32;<emphasis role="keyword">sizeof</emphasis>(rnd)));
</computeroutput></literallayout></para>

<para><formalpara><title>Remarks</title>

<para></para>
</formalpara>
<para>

<para>SCB is a cost based key derivation function (KDF) that uses the Keccak cSHAKE XOF function, to produce pseudo-random bytes from a seeded custom SHAKE generator. <?linebreak?>If a 32-byte key is used, the implementation uses the cSHAKE-256 implementation for pseudo-random generation, if a 64-byte key is used, the generator uses cSHAKE-512. <?linebreak?>The CPU cost feature is an iteration count in the cost mechanism, it determines the number of times both the state absorption and memory scattering functions execute. The Memory cost, is the maximum number of mebibytes (MiB) the internal cache uses, during execution of the memory cost mechanism. <?linebreak?>The L2 cache mechanism can be changed to a doubling of 128 KiB (128, 256, 512, 1024 KiB), doubling the cache sizes above the default 256 KiB, also means that the minimum memory cost must be doubled, L2=512 Kib, minimum memcost is 2, 1024 KiB minimum memcost is 4 etc. The generator can be updated with new seed material, which is absorbed into the Keccak state.</para>
</para>
For additional usage examples, see scb_test.h. <?linebreak?> NIST: SHA3 Fips202 <link xlink:href="http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf">http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf</link> NIST: SP800-185 <link xlink:href="http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pd">http://nvlpubs.nist.gov/nistpubs/SpecialPublications/NIST.SP.800-185.pd</link> NIST: SHA3 Keccak Submission <link xlink:href="http://keccak.noekeon.org/Keccak-submission-3.pdf">http://keccak.noekeon.org/Keccak-submission-3.pdf</link> NIST: SHA3 Keccak Slides <link xlink:href="http://csrc.nist.gov/groups/ST/hash/sha-3/documents/Keccak-slides-at-NIST.pdf">http://csrc.nist.gov/groups/ST/hash/sha-3/documents/Keccak-slides-at-NIST.pdf</link> NIST: SHA3 Third-Round Report <link xlink:href="http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf">http://nvlpubs.nist.gov/nistpubs/ir/2012/NIST.IR.7896.pdf</link> Team Keccak: Specifications summary <link xlink:href="https://keccak.team/keccak_specs_summary.html">https://keccak.team/keccak_specs_summary.html</link> </para>
</section>
<section>
<title>Function Documentation</title>
<anchor xml:id="_scb_8h_1a12d0a4d316949c8e927055d7d8de97af"/><section>
    <title>qsc_scb_dispose()</title>
<indexterm><primary>qsc_scb_dispose</primary><secondary>scb.h</secondary></indexterm>
<indexterm><primary>scb.h</primary><secondary>qsc_scb_dispose</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_scb_dispose (<link linkend="_structqsc__scb__state">qsc_scb_state</link> * ctx)</computeroutput></para><para>

<para>Dispose of the DRBG state. </para>
</para>

<para><warning><title>Warning</title>

<para>The dispose function must be called when disposing of the cipher. This function destroys the internal state of the cipher.</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The DRBG state structure </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_scb_8h_1a2c5f0aa797f606428c24c90121167ec9"/><section>
    <title>qsc_scb_generate()</title>
<indexterm><primary>qsc_scb_generate</primary><secondary>scb.h</secondary></indexterm>
<indexterm><primary>scb.h</primary><secondary>qsc_scb_generate</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_scb_generate (<link linkend="_structqsc__scb__state">qsc_scb_state</link> * ctx, uint8_t * output, size_t otplen)</computeroutput></para><para>

<para>Generate pseudo-random bytes using the random provider. </para>
</para>

<para><warning><title>Warning</title>

<para>Initialize must first be called before this function can be used.</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The function state </para>
</entry>
                            </row>
                            <row>
<entry>output</entry><entry>
<para>The pseudo-random output array </para>
</entry>
                            </row>
                            <row>
<entry>otplen</entry><entry>
<para>The requested number of bytes to generate </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_scb_8h_1a0d452fcb95ea81c7fc7e39910525321b"/><section>
    <title>qsc_scb_initialize()</title>
<indexterm><primary>qsc_scb_initialize</primary><secondary>scb.h</secondary></indexterm>
<indexterm><primary>scb.h</primary><secondary>qsc_scb_initialize</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_scb_initialize (<link linkend="_structqsc__scb__state">qsc_scb_state</link> * ctx, const uint8_t * seed, size_t seedlen, const uint8_t * info, size_t infolen, size_t cpucost, size_t memcost)</computeroutput></para><para>

<para>Initialize the pseudo-random provider state with a seed and optional personalization string. </para>
</para>

<para>
                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The function state </para>
</entry>
                            </row>
                            <row>
<entry>seed</entry><entry>
<para>[const] The random seed, 32 bytes of seed instantiates the 256-bit generator, 64 bytes the 512-bit generator </para>
</entry>
                            </row>
                            <row>
<entry>seedlen</entry><entry>
<para>The length of the input seed </para>
</entry>
                            </row>
                            <row>
<entry>info</entry><entry>
<para>[const] The optional personalization string </para>
</entry>
                            </row>
                            <row>
<entry>infolen</entry><entry>
<para>The length of the personalization string </para>
</entry>
                            </row>
                            <row>
<entry>cpucost</entry><entry>
<para>The number of iterations the internal cost mechanism is executed </para>
</entry>
                            </row>
                            <row>
<entry>memcost</entry><entry>
<para>The memory cost is the number of mebibytes used by the cost mechanism, minimum is 1, maximum 10000 </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
<anchor xml:id="_scb_8h_1a974f89f0ba4e953d66e92fcbeae568c4"/><section>
    <title>qsc_scb_update()</title>
<indexterm><primary>qsc_scb_update</primary><secondary>scb.h</secondary></indexterm>
<indexterm><primary>scb.h</primary><secondary>qsc_scb_update</secondary></indexterm>
<para><computeroutput>QSC_EXPORT_API void qsc_scb_update (<link linkend="_structqsc__scb__state">qsc_scb_state</link> * ctx, const uint8_t * seed, size_t seedlen)</computeroutput></para><para>

<para>Update the random provider with new keying material. </para>
</para>

<para><warning><title>Warning</title>

<para>Initialize must first be called before this function can be used.</para>
</warning>

                <formalpara>
                    <title>
Parameters</title>
                    <para>
                    <table frame="all">
                        <tgroup cols="2" align="left" colsep="1" rowsep="1">
                        <colspec colwidth="1*"/>
                        <colspec colwidth="4*"/>
                        <tbody>
                            <row>
<entry>ctx</entry><entry>
<para>[struct] The function state </para>
</entry>
                            </row>
                            <row>
<entry>seed</entry><entry>
<para>[const] The random update seed </para>
</entry>
                            </row>
                            <row>
<entry>seedlen</entry><entry>
<para>The length of the update seed </para>
</entry>
                            </row>
                        </tbody>
                        </tgroup>
                    </table>
                    </para>
                </formalpara>
                </para>
</section>
</section>
</section>
